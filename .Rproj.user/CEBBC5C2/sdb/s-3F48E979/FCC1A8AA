{
    "contents" : "library( MASS );\nlibrary( ROCR );\nlibrary( stats );\nlibrary( matrixStats)\n\n\n# Bae detector. Uses median values instaad of mean values in the \n# minkowski formula. Uses a p value of 2.41\n\nbaeTrain <- function( YTrain ) {\n  dmod <- list( mean  = colMeans( YTrain ),\n                median = colMedians( YTrain),]\n                ad = colMads(YTrain)^2,\n                data = YTrain,\n                covInv = ginv( cov( YTrain ) ) );\n  return( dmod );\n}\n\nbaeScore <- function( dmod, YScore ) {\n  \n  p <- length( dmod$mean );\n  n <- nrow( YScore );\n  \n  if( ncol(YScore) != p ) stop(\"Training/test feature length mismatch \");\n  \n  meanMatrix <- matrix( dmod$mean, byrow=TRUE, nrow=n, ncol=p );\n  medianMatrix <- matrix( dmod$median, byrow=TRUE, nrow=n, ncol=p );\n  adMatrix <- matrix(dmod$ad, byrow=TRUE, nrow = n, ncol=p);\n  \n  scaled <- abs( YScore - meanMatrix ) %*% diag(1/dmod$ad)\n  manhS <- rowSums(scaled)\n  \n  median <- rowSums( abs( YScore - medianMatrix ) );\n  manh <- rowSums( abs( YScore - meanMatrix ) );\n  mahal <- mahalanobis(YScore,dmod$mean,dmod$covInv,inverted=T);\n  bae <- rowSums(abs((YScore-medianMatrix))^.241)^(1/.241);\n  \n  return( bae );\n}\n\ndetectorSet = list(\n  bae = list( train = baeTrain,\n              score = baeScore ));\n\n###########################################################################\n# 2. Evaluation procedures\n###########################################################################\n# The calculateEqualError function takes a set of user scores and\n# impostor scores, makes an ROC curve using the ROCR functionality,\n# and then geometrically calculates the point at which the miss and\n# false-alarm (i.e., false-negative and false-positive) rates are\n# equal.\n\ncalculateEqualError <- function( userScores, impostorScores ) {\n  \n  write(userScores,\"user\");\n  write(impostorScores,\"impostor\")\n  \n  predictions <- c( userScores, impostorScores );\n  labels <- c( rep( 0, length( userScores ) ),\n               rep( 1, length( impostorScores ) ) );\n  pred <- prediction( predictions, labels );\n  missrates <- pred@fn[[1]] / pred@n.pos[[1]];\n  \n  farates <- pred@fp[[1]] / pred@n.neg[[1]];\n  \n  comG <- cbind(missrates,farates);\n  \n  # Find the point on the ROC with miss slightly >= fa, and the point\n  # next to it with miss slightly < fa.\n  \n  dists <- missrates - farates;\n  idx1 <- which( dists == min( dists[ dists >= 0 ] ) );\n  idx2 <- which( dists == max( dists[ dists < 0 ] ) );\n  stopifnot( length( idx1 ) == 1 );\n  stopifnot( length( idx2 ) == 1 );\n  stopifnot( abs( idx1 - idx2 ) == 1 );\n  \n  # Extract the two points as (x) and (y), and find the point on the\n  # line between x and y where the first and second elements of the\n  # vector are equal.  Specifically, the line through x and y is:\n  #   x + a*(y-x) for all a, and we want a such that\n  #   x[1] + a*(y[1]-x[1]) = x[2] + a*(y[2]-x[2]) so\n  #   a = (x[1] - x[2]) / (y[2]-x[2]-y[1]+x[1])\n  \n  x <- c( missrates[idx1], farates[idx1] );\n  y <- c( missrates[idx2], farates[idx2] );\n  a <- ( x[1] - x[2] ) / ( y[2] - x[2] - y[1] + x[1] );\n  eer <- x[1] + a * ( y[1] - x[1] );\n  return( eer );\n}\n\n# The evaluateSubject function takes a password-timing data frame, an\n# ID for one of the subjects, and an anomaly detector's training and\n# scoring functions.  It performs the training/scoring procedure for\n# that subject, extracting the appropriate password-timing matrices,\n# running the training and scoring functions, and then running the\n# analysis to calculate the equal-error rates.  The equal-error rate\n# for the subject is returned.\n\nevaluateSubject <- function( X, evalSubject, detectorTrain, detectorScore ) {\n  \n  # Extract the training, user scoring, and impostor scoring matricies\n  # for the subject.  The training matrix is the first 200 password\n  # repetitions for the subject, corresponding to the first 4 sessions\n  # of passwords.  The user scoring matrix is the last 200 password\n  # repetitions, and the impostor scoring matrix is the first 5\n  # repetitions from all the other subjects.\n  YTrain <- as.matrix( subset( X,\n                               subset = ( subject == evalSubject & \n                                            sessionIndex <= 4 ),\n                               select = -c( subject, sessionIndex, rep ) ) );\n  \n  YScore.user <- as.matrix( subset( X,\n                                    subset = ( subject == evalSubject &\n                                                 sessionIndex > 4 ),\n                                    select = -c( subject, sessionIndex, rep ) ) );\n  \n  YScore.impostor <- as.matrix( subset( X,\n                                        subset = ( subject != evalSubject &\n                                                     sessionIndex == 1 &\n                                                     rep <= 5 ),\n                                        select = -c( subject, sessionIndex, rep ) ) );\n  \n  # Run the training and scoring procedures on the appropriate matrices\n  # to obtain the user and impostor scores.\n  dmod <- detectorTrain( YTrain );\n  userScores <- detectorScore( dmod, YScore.user );\n  impostorScores <- detectorScore( dmod, YScore.impostor );\n  \n  # Use the user and impostor scores to calculate the detector's equal\n  # error rate for the evaluation subject.\n  eer <- calculateEqualError( userScores, impostorScores );\n  \n  return( eer );\n}\n\ncalculateAccuracy <- function( userScores, impostorScores ) {\n  \n  return( eer );\n}\n\n###########################################################################\n# 3. Main procedure\n###########################################################################\n#######################\n\ncat(\"Loading the data file\\n\");\ndatafile <- 'DSL-StrongPasswordData.txt';\nif( ! file.exists(datafile) )\n  stop( \"Password data file \",datafile,\" does not exist\");\n\n# Retrieve the data and the list of subjects\n\nX <- read.table( datafile, header = TRUE );\nsubjects <- sort( levels( X$subject ) );\n\n# For each of the detectors, evaluate the detector on each subject,\n# and record the equal-error rates in a data frame.\n\neers <- list();\nfor( detectorName in names( detectorSet ) ) {\n  \n  #######################\n  \n  cat(\"Evaluating the\",detectorName,\"detector\\n\");\n  detectorTrain = detectorSet[[ detectorName ]]$train;\n  detectorScore = detectorSet[[ detectorName ]]$score;\n  eers[[ detectorName ]] <- rep( NA, length(subjects) );\n  n <- length(subjects);\n  for( i in 1:n ) {\n    eer <- evaluateSubject( X, subjects[i],\n                            detectorTrain = detectorTrain,\n                            detectorScore = detectorScore );\n    eers[[ detectorName ]][i] <- eer;\n    cat(\"\\r  \",i,\"/\",n,\":\",eer);\n  }\n  cat(\"\\r  average equal-error:\",mean(eers[[detectorName]]),\"\\n\");\n}\n\n#######################\n\ncat(\"Tabulating results:\\n\");\neers <- data.frame( eers );\nrownames( eers ) <- subjects;\nres <- data.frame(eer.mean = colMeans(eers),\n                  eer.sd   = apply( eers, 2, sd ));\nprint( round( res, digits = 7 ) );",
    "created" : 1438601258358.000,
    "dirty" : true,
    "encoding" : "",
    "folds" : "",
    "hash" : "2893977803",
    "id" : "FCC1A8AA",
    "lastKnownWriteTime" : 0,
    "path" : null,
    "project_path" : null,
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "type" : "r_source"
}